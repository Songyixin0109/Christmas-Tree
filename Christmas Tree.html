<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>羊羊 Marry Christmas!</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
    }

    /* GUI 样式 */
    .lil-gui {
      --width: 300px;
      --font-size: 14px;
    }

    .lil-gui.autoPlace {
      right: 10px;
      top: 10px;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18.1/+esm';

    // 着色器代码
    const shaders = {
      particleVertex: `
        uniform float time;
        uniform float size;

        attribute float scale;

        varying vec2 vUv;
        varying float vScale;

        void main(){
          vUv=uv;
          vScale=scale;
          
          vec3 pos=position;
          
          vec4 mvPosition=modelViewMatrix*vec4(pos,1.);
          
          // 粒子大小随高度变化，添加呼吸效果
          float sizeScale=1.-position.y/5.;
          float breathe=1.+sin(time*2.+vScale*6.28)*.2;
          gl_PointSize=size*(sizeScale*2.+.5)*breathe*(300./-mvPosition.z);
          gl_Position=projectionMatrix*mvPosition;
        }
      `,
      particleFragment: `
        uniform vec3 color;
        uniform float time;
        uniform float opacity;
        uniform float glowSize;

        varying vec2 vUv;
        varying float vScale;

        // 添加彩虹色函数
        vec3 rainbow(float t){
          vec3 c=.5+.5*cos(6.28318*(t+vec3(0.,.33,.67)));
          return mix(vec3(1.),c,.7);
        }

        // 添加柔和圆形函数
        float softCircle(vec2 uv,float radius,float softness){
          float dist=length(uv);
          return 1.-smoothstep(radius-softness,radius+softness,dist);
        }

        void main(){
          // 计算到粒子中心的距离，并归一化
          vec2 center=gl_PointCoord-vec2(.5);
          float dist=length(center);
          
          // 创建多层柔和圆形，使用 glowSize 控制发光范围
          float mainGlow=softCircle(center,.35*glowSize,.3*glowSize);
          float innerGlow=softCircle(center,.2*glowSize,.1*glowSize);
          float coreGlow=softCircle(center,.1*glowSize,.05*glowSize);
          
          // 基于位置和时间的彩虹色
          float colorTime=time*.5+vScale*5.;
          vec3 rainbowColor=rainbow(colorTime);
          
          // 增强闪烁效果
          float sparkle=sin(time*3.+vScale*10.)*.5+.5;
          sparkle*=sin(time*2.+vScale*5.)*.5+.75;
          sparkle+=sin(time*8.+vScale*20.)*.25;
          
          // 组合不同层的发光效果
          float strength=mainGlow*.5+innerGlow*.3+coreGlow*.2;
          strength*=.6+sparkle*.8;
          
          // 颜色渐变和混合
          vec3 baseColor=mix(color,rainbowColor,.8);
          vec3 finalColor=baseColor*(strength*2.);
          
          // 增强发光效果，使用更柔和的衰减
          float glow=exp(-dist*2.)*smoothstep(1.,.0,dist);
          vec3 glowColor=rainbow(colorTime+dist);
          finalColor+=glowColor*glow*1.;
          
          // 增强高光效果，使用更圆润的形状
          float highlight=pow(coreGlow,2.)*sparkle;
          finalColor+=vec3(1.)*highlight*1.;
          
          // 确保边缘完全透明
          float alpha=strength*opacity*smoothstep(1.,.7,dist);
          
          gl_FragColor=vec4(finalColor,alpha);
        }
      `,
      starParticleVertex: `
        uniform float time;
        uniform float size;

        attribute float scale;
        attribute float lifetime;
        attribute vec3 velocity;

        varying vec2 vUv;
        varying float vScale;
        varying float vLifetime;

        void main(){
          vUv=uv;
          vScale=scale;
          
          // 计算粒子当前生命周期
          float t=mod(time+lifetime,1.);
          vLifetime=t;
          
          // 根据生命周期和速度更新位置
          vec3 pos=position+velocity*t*2.;
          
          vec4 mvPosition=modelViewMatrix*vec4(pos,1.);
          
          // 粒子大小随生命周期变化
          float fadeIn=smoothstep(0.,.1,t);
          float fadeOut=1.-smoothstep(.5,1.,t);
          gl_PointSize=size*scale*(fadeIn*fadeOut)*(300./-mvPosition.z);
          
          gl_Position=projectionMatrix*mvPosition;
        }
      `,
      starParticleFragment: `
        uniform vec3 color;
        uniform float opacity;
        uniform float glowSize;

        varying vec2 vUv;
        varying float vScale;
        varying float vLifetime;

        void main(){
          vec2 center=gl_PointCoord-vec2(.5);
          float dist=length(center);
          
          // 创建柔和的圆形
          float strength=1.-smoothstep(0.,.5,dist);
          
          // 根据生命周期调整透明度
          float fadeIn=smoothstep(0.,.1,vLifetime);
          float fadeOut=1.-smoothstep(.5,1.,vLifetime);
          float alpha=strength*fadeIn*fadeOut*opacity;
          
          // 发光效果
          vec3 finalColor=color*strength;
          finalColor+=color*.5*(1.-dist);
          
          gl_FragColor=vec4(finalColor,alpha);
        }
      `,
      fallingStarVertex: `
        uniform float time;
        uniform float size;

        attribute float scale;
        attribute float lifetime;
        attribute vec3 velocity;

        varying float vLifetime;

        void main(){
          vLifetime=lifetime;
          
          // 更新位置
          vec3 pos=position+velocity*lifetime;
          
          vec4 mvPosition=modelViewMatrix*vec4(pos,1.);
          
          // 大小随距离变化
          gl_PointSize=size*scale*(800./-mvPosition.z);
          
          gl_Position=projectionMatrix*mvPosition;
        }
      `,
      fallingStarFragment: `
        uniform vec3 color;
        uniform float opacity;
        uniform float time;

        varying float vLifetime;

        void main(){
          vec2 center=gl_PointCoord-vec2(.5);
          float dist=length(center);
          
          // 创建星星形状
          float strength=1.-smoothstep(0.,.4,dist);
          
          // 闪烁效果
          float fastTwinkle=sin(vLifetime*15.)*.5+.5;
          float slowTwinkle=sin(vLifetime*5.)*.5+.5;
          float twinkle=fastTwinkle*slowTwinkle;
          
          // 消失效果
          float fade=1.-smoothstep(5.,6.,vLifetime);
          
          // 增强发光效果
          vec3 finalColor=color*(strength*(1.+twinkle*.5));
          finalColor+=vec3(1.,1.,.8)*pow(1.-dist,3.)*twinkle;
          float alpha=strength*fade*opacity;
          
          gl_FragColor=vec4(finalColor,alpha);
        }
      `,
      starVertex: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;

        void main(){
          vNormal=normalMatrix*normal;
          vPosition=position;
          
          vec4 mvPosition=modelViewMatrix*vec4(position,1.);
          vViewPosition=-mvPosition.xyz;
          gl_Position=projectionMatrix*mvPosition;
        }
      `,
      starFragment: `
        uniform vec3 color;
        uniform vec3 glowColor;
        uniform float glowStrength;
        uniform float glowRange;
        uniform float time;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;

        void main(){
          // 计算视线方向
          vec3 viewDir=normalize(vViewPosition);
          
          // 基础发光效果
          float glow=pow(.8-dot(vNormal,viewDir),3.);
          
          // 边缘发光
          float fresnel=pow(1.-abs(dot(vNormal,viewDir)),3.);
          
          // 脉冲动画
          float pulse=.8+.2*sin(time*2.);
          
          // 从中心向外的渐变
          float dist=length(vPosition.xy);
          float centerGlow=1.-smoothstep(0.,glowRange,dist);
          
          // 合并所有发光效果
          float brightness=(glow+fresnel*glowStrength+centerGlow)*pulse;
          
          // 混合基础颜色和发光颜色
          vec3 finalColor=mix(color,glowColor,fresnel*.5+centerGlow*.3);
          finalColor*=brightness;
          
          // 添加闪烁效果
          float sparkle=pow(sin(time*5.+dist*10.)*.5+.5,2.)*.3;
          finalColor+=glowColor*sparkle;
          
          gl_FragColor=vec4(finalColor,brightness);
        }
      `
    };

    // 场景管理类
    class Scene {
      constructor(container) {
        // 创建Three.js场景
        this.scene = new THREE.Scene()
        this.scene.background = new THREE.Color(0x000000)

        // 创建透视相机，参数：视角、宽高比、近裁剪面、远裁剪面
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)

        // 设置相机初始位置
        this.camera.position.set(4, 3.2, 5) // 设置相机位置
        this.camera.lookAt(0, 2.5, 0) // 让相机看向树的中心点

        // 创建轨道控制器
        this.controls = new OrbitControls(this.camera, container)
        this.controls.enableDamping = true // 启用阻尼效果
        this.controls.dampingFactor = 0.05 // 设置阻尼系数
        this.controls.minDistance = 3 // 设置最小缩放距离
        this.controls.maxDistance = 20 // 设置最大缩放距离
        this.controls.maxPolarAngle = Math.PI / 1.5 // 限制垂直旋转角度
        this.controls.target.set(0, 2.5, 0) // 设置控制器的焦点

        // 添加环境光
        const ambientLight = new THREE.AmbientLight(0x333333)
        this.scene.add(ambientLight)

        // 添加点光源
        const pointLight = new THREE.PointLight(0xffffff, 1, 10)
        pointLight.position.set(0, 0.5, 0)
        pointLight.castShadow = true
        this.scene.add(pointLight)
      }

      /**
       * 处理窗口大小变化
       * 更新相机的宽高比和投影矩阵
       */
      handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight
        this.camera.updateProjectionMatrix()
      }

      /**
       * 更新轨道控制器
       */
      update() {
        this.controls.update()
      }
    }

    // 渲染器类
    class Renderer {
      /**
       * @param {HTMLElement} container - 渲染器的容器元素
       */
      constructor(container) {
        // 创建WebGL渲染器，启用抗锯齿
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true
        })
        this.renderer.shadowMap.enabled = true
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap
        // 设置渲染器尺寸为窗口大小
        this.renderer.setSize(window.innerWidth, window.innerHeight)
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping
        this.renderer.toneMappingExposure = 1.0
        // 将渲染器的canvas元素添加到容器中
        container.appendChild(this.renderer.domElement)

        // 后期处理相关属性
        this.composer = null
        this.renderPass = null
        this.bloomPass = null
        this.outputPass = null
      }

      /**
       * 设置后期处理效果
       * @param {THREE.Scene} scene - 要渲染的场景
       * @param {THREE.Camera} camera - 用于渲染的相机
       */
      setupPostProcessing(scene, camera, params) {
        // 创建渲染通道
        this.renderPass = new RenderPass(scene, camera)

        // 创建泛光通道
        this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), params.后期处理.发光强度, params.后期处理.发光半径, params.后期处理.发光阈值)

        // 创建输出通道
        this.outputPass = new OutputPass()

        // 创建效果组合器
        this.composer = new EffectComposer(this.renderer)
        this.composer.addPass(this.renderPass)
        this.composer.addPass(this.bloomPass)
        this.composer.addPass(this.outputPass)
      }

      /**
       * 处理窗口大小变化
       * 更新渲染器的尺寸
       */
      handleResize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight)
        if (this.composer) {
          this.composer.setSize(window.innerWidth, window.innerHeight)
        }
      }

      /**
       * 渲染场景
       * @param {THREE.Scene} scene - 要渲染的场景
       * @param {THREE.Camera} camera - 用于渲染的相机
       */
      render(scene, camera) {
        if (this.composer) {
          this.composer.render()
        } else {
          this.renderer.render(scene, camera)
        }
      }
      
      updatePostProcessingParams(newParams) {
        if (this.bloomPass) {
          this.bloomPass.strength = newParams.后期处理.发光强度;
          this.bloomPass.radius = newParams.后期处理.发光半径;
          this.bloomPass.threshold = newParams.后期处理.发光阈值;
        }
        
        if (this.renderer) {
          this.renderer.toneMappingExposure = newParams.后期处理.曝光度;
        }
      }
    }

    // 控制器类
    class Controls {
      /**
       * @param {Object} params - 可调节的参数对象
       * @param {Renderer} renderer - 渲染器实例
       * @param {Scene} scene - 场景实例
       * @param {Object} callbacks - 参数变化时的回调函数集合
       */
      constructor(params, renderer, scene, callbacks) {
        this.gui = new GUI({ autoPlace: true, width: 300 });
        this.params = params;
        this.renderer = renderer;
        this.scene = scene;
        this.callbacks = callbacks;
        this.setupControls();
      }

      /**
       * 设置控制面板
       */
      setupControls() {
        // 创建树参数控制文件夹
        const treeFolder = this.gui.addFolder('圣诞树参数');
        treeFolder.open();
        
        // 粒子数量控制
        treeFolder.add(this.params, '粒子数量', 1000, 10000, 100)
          .name('粒子数量')
          .onChange(this.callbacks.onTreeUpdate);
        
        // 粒子大小控制
        treeFolder.add(this.params, '粒子大小', 0.01, 0.2, 0.01)
          .name('粒子大小')
          .onChange(this.callbacks.onParticleSize);
        
        // 闪耀大小控制
        treeFolder.add(this.params, '闪耀大小', 0.1, 2.0, 0.1)
          .name('闪耀大小')
          .onChange((value) => {
            if (this.scene.scene.children.find((child) => child.name === 'treeParticles')) {
              const tree = this.scene.scene.children.find((child) => child.name === 'treeParticles');
              if (tree.material.uniforms) {
                tree.material.uniforms.glowSize.value = value;
              }
            }
          });
        
        // 树高度控制
        treeFolder.add(this.params, '树高', 3, 10, 0.1)
          .name('树高')
          .onChange(() => {
            this.callbacks.onTreeUpdate();
            this.callbacks.onStarUpdate();
          });
        
        // 树宽度控制
        treeFolder.add(this.params, '树宽', 1.0, 3.0, 0.1)
          .name('树宽')
          .onChange(this.callbacks.onTreeUpdate);
        
        // 旋转速度控制
        treeFolder.add(this.params, '旋转速度', 0, 0.01, 0.001)
          .name('旋转速度');
        
        // 透明度控制
        treeFolder.add(this.params, '透明度', 0.1, 1.0, 0.1)
          .name('透明度')
          .onChange(this.callbacks.onOpacityChange);

        // 创建星星参数控制文件夹
        const starFolder = this.gui.addFolder('星星参数');
        starFolder.open();
        
        // 星星颜色控制
        starFolder.addColor(this.params, '星星颜色')
          .name('星星颜色')
          .onChange(this.callbacks.onStarUpdate);
        

        // 创建后期处理参数控制文件夹
        const postFolder = this.gui.addFolder('后期处理');
        postFolder.open();
        
        // 发光效果控制
        postFolder.add(this.params.后期处理, '发光强度', 0, 2, 0.1)
          .name('发光强度')
          .onChange((value) => {
            if (this.renderer.bloomPass) {
              this.renderer.bloomPass.strength = value;
            }
          });
        
        postFolder.add(this.params.后期处理, '发光半径', 0, 1, 0.1)
          .name('发光半径')
          .onChange((value) => {
            if (this.renderer.bloomPass) {
              this.renderer.bloomPass.radius = value;
            }
          });
        
        postFolder.add(this.params.后期处理, '发光阈值', 0, 1, 0.1)
          .name('发光阈值')
          .onChange((value) => {
            if (this.renderer.bloomPass) {
              this.renderer.bloomPass.threshold = value;
            }
          });
        
        postFolder.add(this.params.后期处理, '曝光度', 0.1, 3, 0.1)
          .name('曝光度')
          .onChange((value) => {
            if (this.renderer.renderer) {
              this.renderer.renderer.toneMappingExposure = value;
            }
          });
      }
    }

    // 圣诞树类
    class ChristmasTree {
      /**
       * @param {THREE.Scene} scene - Three.js场景
       * @param {Object} params - 圣诞树的参数配置
       */
      constructor(scene, params, shaders) {
        this.scene = scene
        this.params = params
        this.shaders = shaders
        this.points = null // 树的粒子系统
        this.star = null // 树顶的星星
        this.time = 0
        this.starParticles = null // 添加星星粒子系统
        this.ground = null
        this.fallingStars = []
        this.lastStarTime = 0 // 用于控制星星生成频率

        // 创建圆形粒子纹理
        this.particleTexture = this.createCircleTexture()

        this.createTree()
        this.createGround()
        this.loadStar()
      }

      /**
       * 创建圆形纹理
       */
      createCircleTexture() {
        const canvas = document.createElement('canvas')
        canvas.width = 64
        canvas.height = 64

        const context = canvas.getContext('2d')
        const centerX = canvas.width / 2
        const centerY = canvas.height / 2
        const radius = canvas.width / 3

        // 创建径向渐变
        const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius)
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)')
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)')
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)')

        // 绘制圆形
        context.fillStyle = gradient
        context.beginPath()
        context.arc(centerX, centerY, radius, 0, Math.PI * 2)
        context.fill()

        return new THREE.CanvasTexture(canvas)
      }

      /**
       * 创建圣诞树的粒子系统
       * 使用随机分布的粒子生成圆锥形的树
       */
      createTree() {
        const oldPoints = this.scene.children.find((child) => child.isPoints && child.name === 'treeParticles')
        if (oldPoints) this.scene.remove(oldPoints)

        // 计算总粒子数（外层螺旋 + 内部锥形）
        const spiralParticles = Math.floor(this.params.粒子数量 * 0.7) // 70%的粒子用于螺旋
        const coneParticles = this.params.粒子数量 - spiralParticles // 30%的粒子用于锥形

        const particles = new THREE.BufferGeometry()
        const positions = new Float32Array(this.params.粒子数量 * 3)
        const scales = new Float32Array(this.params.粒子数量)
        const colors = new Float32Array(this.params.粒子数量 * 3)

        // 定义基础颜色
        const baseColors = [
          new THREE.Color(0xff0000), // 红色
          new THREE.Color(0x00ff00), // 绿色
          new THREE.Color(0x0000ff), // 蓝色
          new THREE.Color(0xffff00), // 黄色
          new THREE.Color(0xff00ff), // 紫色
          new THREE.Color(0x00ffff) // 青色
        ]

        // 1. 创建外层螺旋
        for (let i = 0; i < spiralParticles; i++) {
          const i3 = i * 3
          const heightRatio = i / spiralParticles
          const height = heightRatio * this.params.树高

          // 螺旋角度随高度变化
          const spiralAngle = heightRatio * Math.PI * 20 + Math.random() * Math.PI * 0.5
          const baseRadius = (1 - heightRatio) * this.params.树宽
          const radiusOffset = Math.random() * baseRadius * 0.3
          const radius = baseRadius * (0.8 + Math.random() * 0.4) + radiusOffset

          positions[i3] = Math.cos(spiralAngle) * radius
          positions[i3 + 1] = height
          positions[i3 + 2] = Math.sin(spiralAngle) * radius

          scales[i] = Math.random()

          // 颜色设置
          const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)]
          const colorRatio = heightRatio * 0.8 + Math.random() * 0.2
          colors[i3] = baseColor.r * colorRatio
          colors[i3 + 1] = baseColor.g * colorRatio
          colors[i3 + 2] = baseColor.b * colorRatio
        }

        // 2. 创建内部锥形
        for (let i = 0; i < coneParticles; i++) {
          const i3 = (i + spiralParticles) * 3
          const heightRatio = i / coneParticles
          const height = heightRatio * this.params.树高

          // 计算锥形半径（随高度线性减小）
          const maxRadius = this.params.树宽 * 0.6 // 锥形基础半径比外层小一些
          const radius = (1 - heightRatio) * maxRadius * (0.8 + Math.random() * 0.4)

          // 在圆形横截面内随机分布
          const angle = Math.random() * Math.PI * 2
          positions[i3] = Math.cos(angle) * radius
          positions[i3 + 1] = height
          positions[i3 + 2] = Math.sin(angle) * radius

          scales[i + spiralParticles] = Math.random()

          // 内部粒子使用亮的颜色
          const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)]
          const colorRatio = heightRatio * 0.5 + 0.5 + Math.random() * 0.2 // 保持较高的亮度
          colors[i3] = baseColor.r * colorRatio
          colors[i3 + 1] = baseColor.g * colorRatio
          colors[i3 + 2] = baseColor.b * colorRatio
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3))
        particles.setAttribute('scale', new THREE.BufferAttribute(scales, 1))
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3))

        // 创建自定义着色器材质
        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            size: { value: this.params.粒子大小 },
            color: { value: new THREE.Color(1, 1, 1) },
            opacity: { value: this.params.透明度 },
            glowSize: { value: this.params.闪耀大小 }
          },
          vertexShader: this.shaders.particleVertex,
          fragmentShader: this.shaders.particleFragment,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          vertexColors: true
        })

        this.points = new THREE.Points(particles, material)
        this.points.name = 'treeParticles'
        this.scene.add(this.points)
      }

      /**
       * 创建星周围的粒子效果
       */
      createStarParticles() {
        const oldParticles = this.scene.children.find((child) => child.name === 'starParticles')
        if (oldParticles) this.scene.remove(oldParticles)

        const particleCount = 200 // 增加粒子数量
        const geometry = new THREE.BufferGeometry()
        const positions = new Float32Array(particleCount * 3)
        const scales = new Float32Array(particleCount)
        const colors = new Float32Array(particleCount * 3)
        // 添加生命周期和速度属性
        const lifetimes = new Float32Array(particleCount)
        const velocities = new Float32Array(particleCount * 3)

        // 创建从中心向外发射的粒子
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3
          // 初始位置在星星内部的小范围内随机分布
          const radius = Math.random() * 0.1 // 初始半径小
          const theta = Math.random() * Math.PI * 2
          const phi = Math.acos(2 * Math.random() - 1)

          positions[i3] = radius * Math.sin(phi) * Math.cos(theta)
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta)
          positions[i3 + 2] = radius * Math.cos(phi)

          // 设置向外的速度方向
          const speed = 0.1 + Math.random() * 0.3 // 随机速度
          velocities[i3] = (positions[i3] / radius) * speed
          velocities[i3 + 1] = (positions[i3 + 1] / radius) * speed
          velocities[i3 + 2] = (positions[i3 + 2] / radius) * speed

          // 随机生命周期
          lifetimes[i] = Math.random()

          scales[i] = Math.random() * 0.8 + 0.7 // 增加基础大小和随机范围

          // 使用星星的颜色
          const color = new THREE.Color(this.params.星星颜色)
          colors[i3] = color.r
          colors[i3 + 1] = color.g
          colors[i3 + 2] = color.b
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
        geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1))
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))
        geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1))
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3))

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            size: { value: 0.04 },
            color: { value: new THREE.Color(this.params.星星颜色) },
            opacity: { value: 1.0 },
            glowSize: { value: 0.7 }
          },
          vertexShader: this.shaders.starParticleVertex,
          fragmentShader: this.shaders.starParticleFragment,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })

        this.starParticles = new THREE.Points(geometry, material)
        this.starParticles.name = 'starParticles'
        if (this.star) {
          this.starParticles.position.copy(this.star.position)
          this.scene.add(this.starParticles)
        }
      }

      loadStar() {
  const oldStar = this.scene.children.find((child) => child.name === 'star')
  if (oldStar) this.scene.remove(oldStar)

  // 使用 Three.js 的 Shape 创建完美五角星
  const starGeometry = this.createPerfectStarGeometry();
  const starMaterial = new THREE.MeshStandardMaterial({
    color: this.params.星星颜色,
    emissive: this.params.星星颜色,
    emissiveIntensity: 1.5,
    metalness: 0.7,
    roughness: 0.2
  });
  
  this.star = new THREE.Mesh(starGeometry, starMaterial);
  this.star.name = 'star';
  this.star.scale.set(0.8, 0.8, 0.8);
  this.star.position.set(0, this.params.树高 + 0.2, 0);
  this.scene.add(this.star);
  this.createStarParticles();
}

createPerfectStarGeometry() {
  const shape = new THREE.Shape();
  const outerRadius = 0.3;
  const innerRadius = 0.15;
  
  for (let i = 0; i < 10; i++) {
    const angle = (i * Math.PI) / 5 - Math.PI / 2; // 从顶部开始
    const radius = i % 2 === 0 ? outerRadius : innerRadius;
    
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    
    if (i === 0) {
      shape.moveTo(x, y);
    } else {
      shape.lineTo(x, y);
    }
  }
  shape.closePath();
  
  // 挤压成3D几何体
  const extrudeSettings = {
    depth: 0.1,
    bevelEnabled: true,
    bevelThickness: 0.02,
    bevelSize: 0.02,
    bevelSegments: 3
  };
  
  const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  
  // 旋转180度，让尖尖朝上
  geometry.rotateX(Math.PI); // 绕X轴旋转180度
  
  return geometry;
}
      /**
       * 创建反射地面
       */
      createGround() {
        const geometry = new THREE.PlaneGeometry(20, 20)
        const material = new THREE.MeshStandardMaterial({
          color: 0x111111,
          metalness: 0.8,
          roughness: 0.3,
          transparent: true,
          opacity: 0.7
        })

        this.ground = new THREE.Mesh(geometry, material)
        this.ground.rotation.x = -Math.PI / 2
        this.ground.position.y = -0.1
        this.ground.receiveShadow = true
        this.scene.add(this.ground)
      }

      /**
       * 创建一个新的落下的星星
       */
      createFallingStar() {
        const geometry = new THREE.BufferGeometry()
        const positions = new Float32Array(1 * 3)
        const scales = new Float32Array(1)
        const lifetimes = new Float32Array(1)
        const velocities = new Float32Array(1 * 3)

        // 随机位置（在上方区域）
        const x = (Math.random() - 0.5) * 15 // 扩大水平分布范围
        const y = 8 + Math.random() * 2
        const z = (Math.random() - 0.5) * 15 // 扩大水平分布范围

        positions[0] = x
        positions[1] = y
        positions[2] = z

        scales[0] = Math.random() * 0.8 + 0.6
        lifetimes[0] = 0

        // 添加轻微的水平漂移
        velocities[0] = (Math.random() - 0.5) * 0.3
        velocities[1] = -1.0 - Math.random() * 0.8
        velocities[2] = (Math.random() - 0.5) * 0.3

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
        geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1))
        geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1))
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3))

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            size: { value: 0.35 },
            color: { value: new THREE.Color(0xffffaa) },
            opacity: { value: 1.0 }
          },
          vertexShader: this.shaders.fallingStarVertex,
          fragmentShader: this.shaders.fallingStarFragment,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })

        const star = new THREE.Points(geometry, material)
        star.startTime = this.time
        this.fallingStars.push(star)
        this.scene.add(star)
      }

      /**
       * 更新圣诞树动画
       * 控制树和星星的旋转
       */
      update() {
        this.time += 0.016
        if (this.points && this.points.material.uniforms) {
          this.points.material.uniforms.time.value = this.time
          this.points.rotation.y += this.params.旋转速度
        }
        if (this.star) {
          this.star.rotation.y += this.params.旋转速度
          // 更新星星颜色
          this.star.material.emissive.set(this.params.星星颜色)
          this.star.material.color.set(this.params.星星颜色)
        }
        // 更新星星粒子系统
        if (this.starParticles && this.starParticles.material.uniforms) {
          this.starParticles.material.uniforms.time.value = this.time
          this.starParticles.material.uniforms.color.value.set(this.params.星星颜色)
          // 让粒子系统跟随星旋转，但有自的运动
          this.starParticles.rotation.y -= this.params.旋转速度 * 0.5
        }

        // 每隔一定时间创建新的星星
        if (this.time - this.lastStarTime > 0.1) {
          // 每0.1秒创建一个新星星，增加生成频率
          this.createFallingStar()
          this.lastStarTime = this.time
        }

        // 更新落下的星星
        this.fallingStars = this.fallingStars.filter((star) => {
          if (!star.material.uniforms) return false

          const lifetime = this.time - star.startTime
          star.material.uniforms.time.value = this.time
          star.geometry.attributes.lifetime.array[0] = lifetime
          star.geometry.attributes.lifetime.needsUpdate = true

          // 如果生命周期超过4秒，移除星星
          if (lifetime > 6.0) {
            this.scene.remove(star)
            return false
          }
          return true
        })
      }
      
      /**
        * 更新参数
        * @param {Object} newParams - 新的参数
        */
      updateParams(newParams) {
        this.params = newParams;

        // 更新粒子大小
        if (this.points && this.points.material.uniforms) {
          this.points.material.uniforms.size.value = newParams.粒子大小;
          this.points.material.uniforms.opacity.value = newParams.透明度;
          this.points.material.uniforms.glowSize.value = newParams.闪耀大小;
        }

        // 更新星星位置
        if (this.star) {
          this.star.position.set(0, newParams.树高 + 0.2, 0);
        }

        // 更新星星粒子颜色
        if (this.starParticles && this.starParticles.material.uniforms) {
          this.starParticles.material.uniforms.color.value.set(newParams.星星颜色);
        }
      }
    }

    // 主程序
    const container = document.getElementById('container');

    const params = {
      粒子数量: 5000,
      粒子大小: 0.05,
      闪耀大小: 0.7,
      树高: 5,
      树宽: 1.8,
      旋转速度: 0.002,
      透明度: 0.8,
      星星颜色: '#ffff00',
      后期处理: {
        发光强度: 0.5,
        发光半径: 0.4,
        发光阈值: 0,
        曝光度: 1.0
      }
    };

    // 初始化场景和渲染器
    const sceneManager = new Scene(container);
    const renderer = new Renderer(container);

    let christmasTree;

    // 设置后期处理
    renderer.setupPostProcessing(sceneManager.scene, sceneManager.camera, params);

    christmasTree = new ChristmasTree(sceneManager.scene, params, shaders);

    // 创建控制器
    const controls = new Controls(params, renderer, sceneManager, {
      onTreeUpdate: () => {
        if (christmasTree) {
          christmasTree.createTree();
        }
      },
      onStarUpdate: () => {
        if (christmasTree) {
          christmasTree.loadStar();
        }
      },
      onParticleSize: (value) => {
        if (christmasTree && christmasTree.points && christmasTree.points.material.uniforms) {
          christmasTree.points.material.uniforms.size.value = value;
        }
      },
      onOpacityChange: (value) => {
        if (christmasTree && christmasTree.points && christmasTree.points.material.uniforms) {
          christmasTree.points.material.uniforms.opacity.value = value;
        }
      }
    });

    const animate = () => {
      requestAnimationFrame(animate);
      if (christmasTree) {
        christmasTree.update();
      }
      sceneManager.update();
      renderer.render(sceneManager.scene, sceneManager.camera);
    };

    animate();

    window.addEventListener('resize', () => {
      sceneManager.handleResize();
      renderer.handleResize();
    });
  </script>
</body>
</html>